#  데코레이터 패턴

#### 필요성

추상 구성요소(추상)가 있고 그것의 구상 구성요소(구현체)에 대한 추가적인 것이 있을 때,  상속을 남용하는 경우가 생긴다. 따라서 기존 코드를 수정하지 않고도 행동을 확장하는 방법이 필요했고 그러한 경우에 이 패턴을 사용할 수 있다.

> **예시**
>
> `cost` 메소드를 가지고있는 *커피*가 추상 클래스가 있고 *다크로스트*가 서브 클래스가 있다면, 고객의 주문에 따른 첨가물(모카, 우유, 휘핑 크림)에 따라서 *다크로스트*의 `cost`는 달라진다. 이때, 이것들을 고려하여 *모카 다크로스트*, *모카 우유 다크로스트*와 같이 서브 클래스를 만드는 것은 좋지 않다.



#### 디자인 원칙

**OCP(Open-Closed Principle)**

클래스는 확장에 대해서는 열려 있어야 하지만 코드 변경에 대해서는 닫혀 있어야 한다.

즉, 데코레이터 패턴은 코드를 수정하지 않으면서 코드를 확장한다.

> **주의**
>
> * 무조건 OCP를 적용하는 것은 시간 낭비가 될 수 있다.
> * 복잡하고 이해하기 힘든 코드만 만들게 되는 부작용이 있을 수 있다.



#### 정의

* 객체에 추가적인 요건을 동적으로 첨가한다. 
* 서브클래스를 만드는 것을 통해서 기능을 유연하게 확장할 수 있는 방법을 제공한다.
* 자신이 장식하고 있는 객체에 어떤 행동을 위임하는 것 외에 원하는 추가적인 작업을 수행 할 수 있다.



#### 단점

* 특정 구상 구성요소인지 확인한 다음 어떤 작업을 처리하는 경우엔 패턴 사용을 고민해야 한다.
  * 왜냐하면, 데코레이터로 감싸지기 때문에 특정 구상 구성요소인지 파악하기 힘들다.
* 복잡하고 이해하기 힘든 코드만 만들게 되는 부작용이 있을 수 있다.



#### 방법

구상 구성요소를 감싸주는 데코레이터들을 사용한다. 이 데코레이터들은 자기가 감싸고 있는 구성요소의 메소드를 호출한 결과에 새로운 기능을 더함으로써 행동을 확장한다.

*코드 참조*



#### 적용 예시

**자바 I/O**

[[[ *FileInpuStream(구성요소)*  ] *BufferInputStream(데코레이터)*  ] *LineNumberInputStream(데코레이터)*  ]

* FileInpuStream : 데이터를 읽어들일 수 있게 해 주는 기본 구성요소
* BufferInputStream: 입력된 내용을 버퍼에 저장, 인터페이스의 `readLine()` 구현
* LineNumberInputStream: 데이터를 읽을 때, 행 번호를 붙여줌





